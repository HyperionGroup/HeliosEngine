//-----------------------------------------------------------------------------
// Copyright (c) 2006-2008 dhpoware. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#if !defined(SMART_PTR_H)
#define SMART_PTR_H

//-----------------------------------------------------------------------------
// Any class derived from the CReferable abstract base class can use the
// smart pointer template class (defined below).
//-----------------------------------------------------------------------------

class CReferable
{
public:
    CReferable() : mNumReferences(0) {}
    virtual ~CReferable() {}

    int IncRef()
    {
        return ++mNumReferences;
    }

    int DecRef()
    {
        return --mNumReferences;
    }

    int RefCount() const
    {
        return mNumReferences;
    }

private:
    int mNumReferences;
};

//-----------------------------------------------------------------------------
// An intrusive reference counting smart pointer template class. This smart
// pointer class only works with objects derived from the CReferable abstract
// class (defined above). Based on ideas presented in Andrei Alexandrescu's
// "Modern C++ Design" and Scott Meyers' "More Effective C++".
//-----------------------------------------------------------------------------

template <typename CReferableType>
class CSmartPtr
{
public:
    CSmartPtr(CReferableType *pCReferable) : mPImpl(0)
    {
        IncRef(pCReferable);
    }

    CSmartPtr(const CSmartPtr &rhs)
        : mPImpl(0)
    {
        IncRef(rhs.mPImpl);
    }

    CSmartPtr() : mPImpl(0) {}

    ~CSmartPtr()
    {
        release();
    }

    static CReferableType *getImpl(const CSmartPtr &sp)
    {
        return sp.mPImpl;
    }

    template <typename T>
    operator CSmartPtr<T>()
    {
        return CSmartPtr<T>(mPImpl);
    }

    CReferableType &operator*() const
    {
        return *mPImpl;
    }

    CReferableType *operator->() const
    {
        return mPImpl;
    }

    CSmartPtr &operator=(const CSmartPtr &rhs)
    {
        if (this != &rhs)
            IncRef(rhs.mPImpl);

        return *this;
    }

    CSmartPtr &operator=(CReferableType *pCReferable)
    {
        IncRef(pCReferable);
        return *this;
    }

    bool operator!() const
    {
        return mPImpl == 0;
    }

    friend bool operator==(const CSmartPtr &lhs, const CReferableType *rhs)
    {
        return lhs.mPImpl == rhs;
    }

    friend bool operator==(const CReferableType *lhs, const CSmartPtr &rhs)
    {
        return lhs == rhs.mPImpl;
    }

    friend bool operator!=(const CSmartPtr &lhs, const CReferableType *rhs)
    {
        return lhs.mPImpl != rhs;
    }

    friend bool operator!=(const CReferableType *lhs, const CSmartPtr &rhs)
    {
        return lhs != rhs.mPImpl;
    }

    template <typename T>
    friend bool operator==(const CSmartPtr &lhs, const T *rhs)
    {
        return lhs.mPImpl == rhs;
    }

    template <typename T>
    friend bool operator==(const T *lhs, const CSmartPtr &rhs)
    {
        return lhs == rhs.mPImpl;
    }

    template <typename T>
    friend bool operator!=(const CSmartPtr &lhs, const T *rhs)
    {
        return lhs.mPImpl != rhs;
    }

    template <typename T>
    friend bool operator!=(const T *lhs, const CSmartPtr &rhs)
    {
        return lhs != rhs.mPImpl;
    }

    template <typename T>
    bool operator==(const CSmartPtr<T> &rhs) const
    {
        return mPImpl == rhs.mPImpl;
    }

    template <typename T>
    bool operator!=(const CSmartPtr<T> &rhs) const
    {
        return mPImpl != rhs.mPImpl;
    }

private:
    class NotNullTester
    {
        void operator delete(void*);
    };

public:
    operator NotNullTester*() const
    {
        if (!mPImpl)
            return 0;

        static NotNullTester n;
        return &n;
    }

private:
    void IncRef(CReferableType *pCReferable)
    {
        if (!mPImpl)
        {
            mPImpl = pCReferable;

            if (mPImpl)
                mPImpl->IncRef();
        }
        else
        {
            if (mPImpl != pCReferable)
            {
                release();
                mPImpl = pCReferable;

                if (mPImpl)
                    mPImpl->IncRef();
            }
        }
    }

    void release()
    {
        if (mPImpl)
        {
            if (mPImpl->DecRef() <= 0)
            {
                delete mPImpl;
                mPImpl = 0;
            }
        }
    }

    CReferableType *mPImpl;
};

#endif