--
-- Root build.ninja solution file generator
--

local ninja = premake.actions.ninja
local solution = premake.solution
local project = premake5.project
local config = premake5.config
local targets = premake5.targets

local ninjaVarLevel = 2		-- higher = use more ninja build vars
local toolsetDef = {}
local prjHasBeenGenerated = {}
ninja.helpMsg = {}

local function mergeTargets(dest, src)
	for cfgName,targets in pairs(src or {}) do
		if cfgName ~= 'All' then
			local v = dest[cfgName] or {}
			dest[cfgName] = concat(v, targets)
		end
	end
end

-- don't extract everything
ninja.notBuildVar = { input=1, output=1, depfileOutput=1 }

ninja.listOfBinaries = {}
ninja.buildEdges = {}

local function addBuildEdge(targetName, inputs, implicitDeps, overrides)
	--[[local t = {}
	t.inputs = inputs
	t.implicitDeps = implicitDeps
	t.overrides = overrides
	ninja.buildEdges[targetName] = t]]
	ninja.buildEdges[targetName] = inputs
end

function ninja.writeHeader(scope)
	if not scope:get('__header') then
		ninja.writeExecRule()
		scope:set('__header', true)
	end
end

--
-- The actual rules & actions to build the solution. Always invoked by the default build.ninja, which contains its dependencies
--
function ninja.generateSolution(sln, scope)
	--_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	--_p('#  This file is not designed to be invoked directly, the build.ninja header file specifies the dependencies')
	--_p('')
	ninja.writeHeader(scope)

	local first = true
	local slnPrjTargets = {}
	for _,prj in ipairs(sln.projects) do

		if first then
			_p('#############################################')
			_p('# Solution ' .. sln.name)
			_p('#############################################')
			_p('')
			first = false
		end
		
		if targets.prjToBuild[prj.name] then
			local prjTargets = ninja.generateProject(prj, scope)
			mergeTargets(slnPrjTargets, prjTargets)
		end
	end

	-- Also export any remaining dependent projects
	for _,prj in pairs(targets.prjToGenerate) do
		ninja.generateProject(prj, scope)
	end

	local slnTargets = {}
	for cfgName,targets in pairs(slnPrjTargets) do
		local slnCfg = sln.name
		if #cfgName > 0 then
			slnCfg = slnCfg ..'.'..cfgName
		end
		local prjTargets = table.concat(targets, ' ')
		if slnCfg ~= prjTargets then
			local buildCmd = 'phony '.. prjTargets
			addBuildEdge(slnCfg, buildCmd)
			_p('# Solution targets')
			_p('build '..slnCfg..': '..buildCmd)
		end
		slnTargets[cfgName] = slnTargets[cfgName] or {}
		table.insert( slnTargets[cfgName], slnCfg )
	end
	_p('')
	scope.alltargets = scope.alltargets or {}
	scope.slntargets = scope.slntargets or {}
	scope.slntargets[sln.name] = slnTargets
	mergeTargets(scope.alltargets, slnTargets)
end

function ninja.writeFooter(scope)
	local prjToGenerate = targets.prjToGenerate or {}

	-- Print binaries
	if _OPTIONS['printBins'] then
		local builddir = ninja.builddir
		local listOfBinaries = ninja.listOfBinaries

		_p('# Print Binaries')
		_p('#######################################')
		local listOfBinariesStr = table.concat(listOfBinaries, ' ')
		local relPathToBins = {}
		for _,v in ipairs(listOfBinaries) do
			local v2 = v
			repeat
				v = v2
				v2 = v:gsub("${([^}]*)}", function(v) return scope:get(v) end)
			until v2==v
			v = path.getabsolute(v)
			if v:startswith(builddir) then
				table.insert( relPathToBins, "$relbuilddir/" .. path.getrelative(builddir, v) )
			else
				table.insert( relPathToBins, v )
			end
		end
		local relPathToBinsStr = table.concat(relPathToBins, ' $\n')

		_p('build printBinaries: echoLines '..listOfBinariesStr)
		_p('  description=Binaries Built :')
		_p('  lines='..relPathToBinsStr)
		_p('')
	end

	-- Write aliases
	_p('# Target aliases')
	_p('#######################################')
	for aliasName,fullProjName in pairs(targets.aliases) do
		if prjToGenerate[fullProjName] then
			_p('build '..aliasName..': phony '..fullProjName)
		end
	end
	_p('')

	-- Write help
	if #ninja.helpMsg > 0 then
		_p('# Ninja help message')
		_p('#######################################')
		_p('')
		local echoNewLine = "\\n$"
		_p('ninjaHelpMsg="$')
		for _,line in ipairs(ninja.helpMsg) do
			_p(line..echoNewLine)
		end
		local slnList = mkstring(getKeys(scope.slntargets))
		local cfgList = Seq:new(scope.slntargets)
		:selectMany(function (v) return getKeys(v) end):unique():mkstring()
		_p(echoNewLine)
		_p(' Available Solutions : '.. slnList..echoNewLine)
		_p(' Available Configurations : '.. cfgList..echoNewLine)
		_p('"')
		_p('build help: exec\n cmd=echo -e $ninjaHelpMsg\n description=\t')
		_p('')
	end

	-- Write the global configuration build targets
	if scope.alltargets then
		_p('# Global configuration build targets')
		_p('#######################################')
		_p('')
		for cfgName,targetList in pairs(scope.alltargets) do
			if #cfgName>0 then
				local buildCmd = 'phony '..table.concat(targetList, ' ')
				addBuildEdge(cfgName, buildCmd)
				_p('build '..cfgName..': '..buildCmd)
			end
		end
		_p('')
	end
end

function ninja.writeDefaultTargets(targetsByCfg)
	-- Write the global configuration build targets
	if targetsByCfg then
		local defaultTarget = targetsByCfg[''] or {}
		if #defaultTarget == 0 then
			-- No default project targets, so build all the configurations instead
			defaultTarget = getKeys(targetsByCfg)
		end

		if #defaultTarget == 0 then
			defaultTarget = { 'nothingtobuild' }
		elseif _OPTIONS['printBins'] and #ninja.listOfBinaries > 0 then
			table.insert( defaultTarget, 'printBinaries')
		end

		-- Build all configurations by default
		_p('# Default build targets')
		_p('#######################################')
		_p('')
		_p('default '..table.concat(defaultTarget, ' '))
		_p('')
	else
		_p('default nothingtobuild')
	end
end

function ninja.generateProject(prj, scope, addToAllTargets)
	if prjHasBeenGenerated[prj] then return prjHasBeenGenerated[prj] end

	if not targets.prjToBuild[prj.name] then
		-- skip this project
		return nil
	end

	-- Write header if it's not already been written
	ninja.writeHeader(scope)

	if not prj.isUsage and prj.isbaked then

		_p('# Project ' .. prj.name)
		_p('##############################')
		_p('')
		ninja.writeToolsets(prj, scope)

		local buildTargets = ninja.writeProjectTargets(prj, scope)
		prjHasBeenGenerated[prj] = buildTargets

		if addToAllTargets then
			scope.alltargets = scope.alltargets or {}
			mergeTargets(scope.alltargets, buildTargets)
		end

		return buildTargets
	else
		return nil
	end
end

function ninja.getToolOverrides(cfg, tool, scope)
	local toolInputs = tool:decorateInputs(cfg, '$out', '$in')
	local toolDef = scope:get(tool.ruleName)

	if not toolDef then return nil end
	-- add any missing vars
	for k,_ in pairs(toolDef) do
		toolInputs[k] = toolInputs[k] or ""
	end

	-- See if we need to override any flags
	local toolOverrides = {}

	for k,v in pairs(toolInputs) do
		v = ninja.esc(v)
		if not ninja.notBuildVar[k] then
			if toolDef[k] ~= v then
				k = tool.ruleName .. '_' .. k
				toolOverrides[k] = v
			end
		end
	end

	return toolOverrides
end

function ninja.getCompileTool(cfg, fileExt, scope)
	local toolsetName = cfg.toolset
	local toolset = premake.tools[toolsetName]

	local compileTool = toolset:getCompileTool(cfg, fileExt)
	local compileOverrides
	if compileTool then
		compileOverrides = ninja.getToolOverrides(cfg, compileTool, scope)
	end

	return compileTool, compileOverrides
end

function ninja.getLinkTool(cfg, scope)
	local toolset = premake.tools[cfg.toolset]

	local linkTool = toolset:getLinkTool(cfg)
	local linkOverrides
	if linkTool then
		linkOverrides = ninja.getToolOverrides(cfg, linkTool, scope)
	end

	return linkTool, linkOverrides
end

local function makeShorterBuildVars(scope, inputs, weight, newVarPrefix)
	-- See if it's worth creating extra build vars
	local extraBuildVars = scope:getBuildVars(inputs, weight, newVarPrefix)
	for k,v in pairs(extraBuildVars) do
		_p(k .. '=' .. v)
	end
end

local function getProjectName(prj)
	local prjTargetName = prj.name
	if prjTargetName == prj.solution.name then
		prjTargetName = prj.name..'.Project'
	end
	return prjTargetName
end

local function getCfgName(cfg)
	return ninja.replaceSpecialChars(cfg.shortname)
end

function ninja.writeProjectTargets(prj, scope)

	if not prj.isbaked then
		return
	end

	local filesPerConfig = ninja.getInputFiles(prj)

	local cfgs = {}
	local prjTargets = {}
	local isCommandProject = prj.isCommandProject		-- a command project has only one configuration (& output) which is equivalent to all variants
	local prjTargetName = getProjectName(prj)

	local defaultBuildVariant = project.getDefaultBuildVariant(prj)
	if not defaultBuildVariant then
		defaultBuildVariant = { buildcfg = 'All' }
	end
	local defaultBuildName = config.getBuildName(defaultBuildVariant)

	-- Validate
	for cfg in project.eachconfig(prj) do
		if not cfg.toolset then
			error("Malformed project '"..prj.name.."', has no toolset specified for kind "..cfg.kind)
		end

		local toolset = premake.tools[cfg.toolset]
		local linkTool = toolset:getLinkTool(cfg)

		if linkTool and not isCommandProject then
			if not cfg.kind then
				if project.inProjectSet(prj, 'export') then
					error("Malformed project '"..prj.name.."', is exported but undefined")
				else
					error("Malformed project '"..prj.name.."', has no kind specified")
				end
			end
			if not cfg.buildtarget then
				error("Malformed project '"..prj.name.."', toolset "..cfg.toolset.." requires buildtarget but none specified")
			end
		end

		cfg.language = prj.language

		-- Only build source gen & command once
		if cfg.kind == 'SourceGen' or cfg.kind == 'Command' then
			isCommandProject = true
		end

		-- Put the default configuration first.
		-- This fixes a problem where auto-generated header files put in the src folders are incorrectly updated
		--  as the script name includes the name of the first cfg processed
		if cfg == prj.configs[defaultBuildName] then
			table.insert(cfgs, 1, cfg)
		else
			table.insert(cfgs, cfg)
		end
	end

	local tmr = timer.start('ninja.writeProjectTargets')

	-- Build each config
	for _,cfg in ipairs(cfgs) do
		local toolsetName = cfg.toolset
		local toolset = premake.tools[toolsetName]
		local allLinkInputs = {}

		local compileTool,compileOverrides = ninja.getCompileTool(cfg, nil, scope)
		local linkTool,linkOverrides = ninja.getLinkTool(cfg, scope)

		-- List of all files in this config
		local filesInCfg = filesPerConfig[cfg]
		local srcdirFull = prj.basedir
		local hasObjdir = iif( isCommandProject, false, true )
		local srcdir = ninja.toRelPath(srcdirFull)
		local objdir = ''
		local targetdir = ''
		if hasObjdir then
			objdir = ninja.toRelPath(cfg.objdir)
			targetdir = ninja.toRelPath(cfg.targetdir)
		end

		-- Replace disallowed special characters
		local cfgname = getCfgName(cfg)

		local numFilesToCompile = #(filesInCfg['Compile'] or {})
		local verboseComments = numFilesToCompile > 5

		-- Generate unique ninja build var names
		local objdirN = objdir
		local targetdirN = targetdir
		local srcdirN = srcdir

		if numFilesToCompile > 2 then
			local foundO, foundT, foundS
			if hasObjdir then
				objdirN,foundO = scope:set('objdir', objdir)
			end
			if targetdir ~= objdir then
				targetdirN,foundT = scope:set('targetdir_' .. cfgname, targetdir)
			else
				targetdirN = objdirN
				foundT = true
			end
			srcdirN,foundS = scope:set('srcdir', srcdir)

			if verboseComments then
				_p('# Compile ' .. prj.name .. ' ['..cfgname..']')
				_p('#------------------------------------')
				_p('')
			end

			if not foundO and hasObjdir and objdir == '' then
				error("objdir is blank")
			end
			if not foundT and targetdir == '' then
				error("targetdir is blank")
			end

			if not foundO and hasObjdir then _p(objdirN ..'='..objdir); end
			if not foundT then _p(targetdirN..'='..targetdir); end
			if not foundS then _p(srcdirN..'='..srcdir); end

			objdirN = ninja.escVarName(objdirN)
			targetdirN = ninja.escVarName(targetdirN)
			srcdirN = ninja.escVarName(srcdirN)

			_p('')
		else
			objdirN = scope:getBest(objdirN)
			targetdirN = scope:getBest(targetdirN)
			srcdirN = scope:getBest(srcdirN)
		end
		local uniqueObjNameSet = {}
		local finalTargetInputs = {}
		
		local extraTargets = ninja.writeBuildRule(cfg, 'prebuild', {}, scope)
		table.insertflat(finalTargetInputs, extraTargets)

		-- Compile source -> object files, for all files in the config
		for fileName,fileCfg in pairs(filesInCfg['Compile'] or {}) do
			if type(fileName) ~= 'number' then
				local sourceFileRel = path.getrelative(srcdirFull, fileName)
				local outputFile

				local extraTargets = ninja.writeBuildRule(cfg, 'compile', fileName, scope) or {}
				if not isCommandProject then
					-- SourceGen projects can have no compile dependencies, otherwise we end up in a loop
					table.insertflat( extraTargets, cfg.compiledepends )
				end

				-- See if it's worth creating extra build vars
				makeShorterBuildVars(scope, extraTargets, numFilesToCompile, 'cdeps')

				-- Check if we need to override the compile tool based on the extension
				local fileExt = fileCfg.extension
				local fileCompileTool = toolset:getCompileTool(cfg, fileExt)
				local fileCompileOverrides = compileOverrides

				if compileTool ~= fileCompileTool then
					fileCompileTool, fileCompileOverrides = ninja.getCompileTool(cfg, fileExt, scope)
				end

				if fileCompileTool then
					-- Check if we can compile the file, and get the object file name
					outputFile = fileCompileTool:getCompileOutput(cfg, fileName, uniqueObjNameSet)
				end

				makeShorterBuildVars(scope, fileCompileOverrides, numFilesToCompile)

				-- Write the build rule
				-- I assume that any build specialisation is only per project+configuration, not per file
				if outputFile then
					local outputFullpath = objdirN..'/'..outputFile

					local buildCmd = fileCompileTool.ruleName..' '..srcdirN..'/'..sourceFileRel
					local buildStr = 'build ' .. outputFullpath ..': '..buildCmd

					local implicitDeps
					if extraTargets and #extraTargets > 0 then
						-- Add implicit dependencies
						implicitDeps = table.concat(extraTargets, ' ')

						if #extraTargets > 1 then
							local uid = string.createhashS(implicitDeps)
							local varName, alreadyExists = scope:getName(implicitDeps, '$null/deps'..uid)
							if not alreadyExists then
								_p('build '..varName..': phony2 '.. implicitDeps)
							end
							_p('')
							implicitDeps = varName
						end

						buildStr = buildStr .. ' | '..implicitDeps
						extraTargets = nil
					end

					_p(buildStr)
					for k,v in pairs(fileCompileOverrides) do
						--v = scope:getBest(v)
						_p(' ' .. k .. '=' .. v)
					end

					addBuildEdge(outputFullpath, buildCmd, implicitDeps, fileCompileOverrides)

					table.insert( allLinkInputs, outputFullpath )
				elseif cfg.kind == 'Command' and not cfg.toolset then
					local fileTarget = srcdirN..'/'..sourceFileRel ..'.exec'
					local buildStr = 'build ' .. fileTarget ..': exec '.. srcdirN..'/'..sourceFileRel
					_p(buildStr)
					addBuildEdge(fileTarget, buildStr, nil, nil)
					table.insert( allLinkInputs, fileTarget )

				elseif (linkTool == nil) or linkTool:isLinkInput(cfg, fileExt ) then
					table.insert( allLinkInputs, srcdirN..'/'..sourceFileRel )
				end

				table.insertflat(finalTargetInputs, extraTargets)
			end -- ~= number
		end
		_p('')

		for _,fileFullpath in ipairs(filesInCfg['Copy'] or {}) do
			-- Copy files
			local fileName = path.getname(fileFullpath)
			local buildCmd = 'copy ' .. fileFullpath
			local buildTarget = targetdirN..'/'..fileName
			addBuildEdge(buildTarget, buildCmd)
			_p('build ' .. buildTarget..' : '..buildCmd)
		end

		for _,fileFullpath in ipairs(filesInCfg['Embed'] or {}) do
			table.insert( allLinkInputs, fileFullpath )
		end

		-- Implicit dependencies : files which affect the build but aren't included in the direct inputs
		local implicitDeps = {}
		local implicitDepInputFiles = filesInCfg['ImplicitDependency'] or {}
		makeShorterBuildVars(scope, implicitDepInputFiles, #implicitDepInputFiles)
		for _,fileFullpath in ipairs(implicitDepInputFiles) do
			table.insert( implicitDeps, fileFullpath )
		end
		for _,lib in ipairs(cfg.linkAsShared or {}) do
			if path.containsSlash(lib) then
				table.insert( implicitDeps, lib )		-- remove this when implicit deps on phony targets work
				if targets.linkTargets[lib] then
					-- Add the implicit dependency on the phony final target, to force any postbuild commands to run
					local linkcfg = targets.linkTargets[lib] 
					lib = getProjectName(linkcfg.project).."."..getCfgName(linkcfg)
					table.insert( implicitDeps, lib )
				end
			end
		end
		for _,lib in ipairs(cfg.linkAsStatic or {}) do
			if path.containsSlash(lib) then
				table.insert( implicitDeps, lib )		-- remove this when implicit deps on phony targets work
				if targets.linkTargets[lib] then
					-- Add the implicit dependency on the phony final target, to force any postbuild commands to run
					local linkcfg = targets.linkTargets[lib] 
					lib = getProjectName(linkcfg.project).."."..getCfgName(linkcfg)
				end
				table.insert( implicitDeps, lib )
			end
		end

		-- Link
		local finalTargetN = prjTargetName.. '.' ..cfgname
		local linkTargetN

		if #allLinkInputs > 0 then

			local extraTargets = ninja.writeBuildRule(cfg, 'link', allLinkInputs, scope)
			table.insertflat(implicitDeps, extraTargets)

			local linkToolRuleName

			if not linkTool then
				if not extraTargets or #extraTargets == 0 then
					if cfg.buildtarget and cfg.buildtarget.name then
						local allInputs = table.concat(allLinkInputs, ' ')
						_p('# Null linker')
						local buildCmd = 'copyIfNewer '..allInputs
						linkTargetN = targetdirN..'/'..cfg.buildtarget.name
						if isCommandProject then
							linkTargetN = prjTargetName
						end
						if linkTargetN ~= allInputs then
							addBuildEdge(linkTargetN, buildCmd)
							_p('build '..linkTargetN..': '..buildCmd)
						end
						table.insert(finalTargetInputs,linkTargetN)
					else
						table.insert(finalTargetInputs,targetdirN)
					end
				else
					table.insertflat(finalTargetInputs, extraTargets)
				end
			else
				if verboseComments then
					_p('# Link ' .. prj.name .. ' ['..cfgname..']')
					_p('#++++++++++++++++++++++++++++++++')
				end

				if linkTool.getOutputFiles then
					-- Use this if your tool outputs multiple files
					local outputFiles = linkTool:getOutputFiles(cfg, allLinkInputs)
					outputFiles = ninja.escPath(outputFiles)
					makeShorterBuildVars(scope, outputFiles, 1)
					linkTargetN = table.concat(outputFiles, ' ')
				else
					linkTargetN = targetdirN..'/'..cfg.buildtarget.name
				end

				local buildCmd = linkTool.ruleName ..' '..table.concat(allLinkInputs, ' ')
				local buildStr = 'build '..linkTargetN..': '..buildCmd

				local implicitDepStr = nil
				if #implicitDeps > 0 then
					implicitDepStr = table.concat(implicitDeps, ' ')
					implicitDepStr = ninja.toRelPath(implicitDepStr)

					if ninjaVarLevel >= 2 then
						local uid = string.createhashS(implicitDepStr)
						local varName, alreadyExists = scope:getName(implicitDepStr, '$null/deps'..uid)
						if not alreadyExists then
							_p('build '..varName..': phony2 '.. implicitDepStr)
						end
						implicitDepStr = varName
					end

					buildStr = buildStr .. ' | ' .. implicitDepStr
				end

				makeShorterBuildVars(scope, linkOverrides, 1)

				_p(buildStr)
				for k,v in pairs(linkOverrides or {}) do
					_p(' ' .. k .. '=' .. v)
				end
				_p('')

				addBuildEdge(linkTargetN, buildCmd, implicitDepStr, linkOverrides)
				
				if linkTool.postbuild then
					local br = linkTool.postbuild(cfg)
					if br then
						local extraTargets = ninja.writeBuildRule2(cfg, br, linkTargetN, scope, {})
						table.insertflat(finalTargetInputs, extraTargets)
					end
				end

				table.insert(finalTargetInputs,linkTargetN)
			end

		end

		-- Post build commands
		local postbuildTargets = ninja.writeBuildRule(cfg, 'postbuild', finalTargetInputs, scope)
		table.insertflat(finalTargetInputs, postbuildTargets)
		
		-- Phony rule to build it all
		if cfg.kind == 'Command' and #finalTargetInputs == 1 then
			finalTargetN = finalTargetInputs[1]
		else
			local buildCmd = 'phony '..table.concat(finalTargetInputs, ' ')
			addBuildEdge(finalTargetN, buildCmd)
			_p('# Final target')
			_p('build '..finalTargetN..': '..buildCmd)
			_p('')
		end
		
		cfg.finalTargetN = finalTargetN

		-- For printBins
		if cfg.kind == 'ConsoleApp' then
			for _,v in ipairs(finalTargetInputs) do
				table.insert( ninja.listOfBinaries, v )
			end
		end

		if cfg.buildwhen ~= 'explicit' then
			prjTargets[cfgname] = { finalTargetN }
		end

	end -- for cfgs
	timer.stop(tmr)

	local defaultTargets = {}

	for cfgName,cfg in pairs(prj.configs or {}) do
		table.insert( defaultTargets, cfg.finalTargetN )  
		if cfg.buildwhen ~= 'explicit' then
			prjTargets[''] = { prjTargetName }
		end
	end
	if not ninja.buildEdges[prjTargetName] then
		_p('# Project build targets')
		_p('build '..prjTargetName..': phony '..table.concat(defaultTargets,' '))
		addBuildEdge(prjTargetName, defaultTargets)
	end
	_p('')

	return prjTargets
end

function ninja.writeBuildRule(cfg, stage, inputs, scope)
	if cfg.buildrule and cfg.buildrule[stage] then
		local finalTargetInputs = {}
		for i,buildrule in ipairs(cfg.buildrule[stage] or {}) do
			local buildTarget = ninja.writeBuildRule2(cfg, buildrule, inputs, scope, finalTargetInputs)
			table.insert(finalTargetInputs, buildTarget)
		end
		_p('')
		return finalTargetInputs
	end
	return nil
end

function ninja.writeBuildRule2(cfg, buildrule, inputs, scope, finalTargetInputs)
	-- Generate a unique name to reference this post build command
	local buildRuleName = cfg.project.name..'.'..cfg.buildcfg..'.'..buildrule.name
	if cfg.kind == 'Command' then
		buildRuleName = cfg.project.name:match("[^/]*$")
	end
	local buildTarget = buildRuleName

	local dir
	if buildrule.dir then
		dir = scope:getBest(buildrule.dir)
	end
	local cmd = buildrule.commands or ''
	if type(cmd) == 'table' then cmd = table.concat(cmd, '\n') end
	
	if not buildrule.language then
		-- raw ninja command, escape any unrecognised $ characters
		local ignore = toSet({ '$in', '$out', '$builddir', '$root', "${in}", "${out}", "${root}", "${builddir}" })
		cmd = cmd:gsub("%$[^$ /]*", function (v)
			if ignore[v] then return v
			else return "$"..v
			end
		end)
		cmd = cmd:gsub('\n','; '):gsub(";;",";")
		if cmd:startswith(";") then
			cmd = cmd:sub(2)
		end
	end
	
	-- get full path to outputs

	local absOutputStr = ""
	if buildrule.outputs then
		local outputs = buildrule.outputs
		if type(outputs) == 'string' then outputs = { outputs } end
		local absOutputs = {}
		for _,v in ipairs(outputs) do
			v = path.getabsolute(v, buildrule.dir)
			if not buildrule.language then
				v = path.asRoot(v)
			end
			absOutputs[#absOutputs+1] = v 
		end
		absOutputStr = table.concat(absOutputs, ' ')
		buildTarget = ninja.toRelPath(absOutputStr)
	end
	cmd = cmd:replaceword("$out",absOutputStr)

	-- check for inputs override
	if buildrule.inputs then
		inputs = {}
		if type(buildrule.inputs) == 'string' then buildrule.inputs = { buildrule.inputs } end
		for _,v in ipairs(buildrule.inputs) do
			v = path.getabsolute(v, buildrule.dir)
			if not buildrule.language then
				v = path.asRoot(v)
			end
			inputs[#inputs+1] = v
		end 
	end

	local implicits = buildrule.dependencies or {}
	if type(implicits) == 'string' then implicits = { implicits } end
	for i,v in ipairs(implicits) do
		implicits[i] = path.getabsolute(v, buildrule.dir)
	end
	implicits = table.concat(implicits, ' ')

	if buildrule.language then
		-- Write the command to a file, and execute it

		-- replace $in with "$@"
		if buildrule.language == 'bash' then
			cmd = cmd:replaceword("$in","$@")
		end

		local script = ninja.toAbsPath(cmd)
		local scriptFilename = cfg.targetdir..'/'..buildRuleName..'.'..buildrule.language
		scriptFilename = ninja.toRelPath(scriptFilename)
		local scriptFilenameFull = scriptFilename:replace("$root", repoRootPlain)
		scriptFilenameFull = scriptFilenameFull:replace("${builddir}", ninja.builddir)

		-- Test if contents are different before writing
		local writeToFile = true
		if os.isfile(scriptFilenameFull) then
			local f = io.open(scriptFilenameFull, 'r')
			local currentScript = f:read('*a')
			io.close(f)
			if currentScript == script then
				writeToFile = false
			end
		end

		if writeToFile then
			local f = io.open(scriptFilenameFull, 'w+')
			f:write(script)
			io.close(f)
		end

		cmd = mkstring( { buildrule.language, scriptFilename, inputs })

		-- Add the script to the implicits so it rebuilds if the command changes
		implicits = implicits..' '..scriptFilename
	end

	repeat
		local cmd2 = cmd
		cmd = scope:getBest(cmd)
	until #cmd2 == #cmd
	--cmd = 'cd '..dir..' && '.. cmd

	-- This fixes the issue where auto-generated header files placed in the source tree incorrectly get
	--  multiple build edges for the same target output, despite the command being the same for each cfg
	if not ninja.buildEdges[buildTarget] then
		if type(inputs) == 'table' then inputs = table.concat(inputs, ' ') end

		if not buildrule.language then
			cmd = cmd:replace("$in", inputs)
		end

		if #implicits > 0 then
			inputs = inputs .. ' | '..implicits
		end

		local buildCmd = 'exec '..inputs
		_p('build '..buildTarget..' : ' .. buildCmd)
		_p(' cmd='..cmd)

		if buildrule.description then
			_p(' description='..buildrule.description)
		end

		addBuildEdge(buildTarget, buildCmd, implicits, { cmd=cmd, description=buildrule.description })
	end
	return buildTarget
end


function ninja.writeEnvironment(sln)
	local arch = ""

	_p('# Environment settings')
	--_p('tooldir=' .. tooldir)
	_p('arch=' .. arch)
	--_p('osver=' .. osver)
	--_p('compilerVer=' .. compilerVer)
	--_p('solution=' .. solutionName)

end

function ninja.writeRoot(buildFileDir)
	local buildpaths = _OPTIONS['buildpaths'] or 'root'

	if buildpaths == 'abs' then
		_p('currentdir='.. path.getabsolute(repoRoot))
		_p('relbuilddir=' .. path.getabsolute(ninja.builddir))
		_p('root='.. path.getabsolute(repoRoot))
		_p('builddir=' .. path.getabsolute(ninja.builddir))

	elseif buildpaths == 'root' then
		_p('currentdir=' .. path.getrelative(buildFileDir, repoRoot))
		_p('root=.')
		if ninja.builddir:contains(repoRootPlain) then
			_p('builddir=' .. path.getrelative(repoRoot, ninja.builddir))
		else
			_p('builddir=' .. ninja.builddir)
		end
		_p('relbuilddir=' .. path.getrelative(buildFileDir, ninja.builddir))

	elseif buildpaths == 'bin' then
		_p('currentdir=' .. path.getrelative(buildFileDir, ninja.builddir))
		if ninja.builddir:contains(repoRootPlain) then
			_p('root='.. path.getrelative(ninja.builddir, repoRoot) )
		else
			_p('root='.. repoRoot )
		end
		_p('builddir=.')
		_p('relbuilddir=' .. path.getrelative(buildFileDir, ninja.builddir))
	else
		error("Invalid buildpaths option "..buildpaths)
	end
	_p('')
end

function ninja.writeExecRule()
	_p('rule exec')
	_p(' command=$cmd')
	_p(' description=$description')
	_p('')
	_p('null=$builddir/.null')
	_p('')
	_p('rule copyIfNewer')
	_p(' command=cp -u $in $out')
	_p('')
	_p('rule phony2')
	_p(' command=touch $out')
	_p(' description=$out')
	_p('')
	_p('build nothingtobuild: exec')
	_p(' description=Nothing to build!')
	_p(' cmd=echo -e "\\x1b[1;31mNothing to build!\\x1b[m"')
	_p('build donothing: phony $builddir/.donothing')
	_p('build $builddir/.donothing: exec')
	_p(' cmd=touch $builddir/.donothing')
	_p(' description=Prepare environment')
	_p('')
	_p('rule echoLines')
	_p(" command=echo $lines | tr ' ' '\\n'")
	_p(' description=$description')
	_p('')
	_p('rule deleteZeroSizedObjs')
	_p(" command=find $builddir/* -size 0c -name '*.o' -type f -exec rm {} \\;")
	_p(' description="Ctrl-C cleanup..."')
	_p('')
	_p('build __cleanup: deleteZeroSizedObjs')
end


--
-- Define any toolsets which are not yet defined
--  Run for each config, for each project
--
function ninja.writeToolsets(prj, scope)

	local tmr = timer.start('ninja.writeToolsets')

	local function _pt(str)
		--toolsetNinjaStr = toolsetNinjaStr .. str .. '\n'
		_p(str)
	end

	local buildpaths = _OPTIONS['buildpaths']
	for cfg in project.eachconfig(prj) do
		local toolsetName = cfg.toolset

		if not toolsetName or toolsetName == '' then
			cfg.toolset = 'gcc'
			printDebug('Toolset not specified for project ' .. cfg.project.name .. ' configuration ' .. cfg.shortname..'. Using '..cfg.toolset)
			toolsetName = cfg.toolset
		end

		local toolset = premake.tools[toolsetName]
		if not toolset then
			error("Invalid toolset '" .. toolsetName .. "' in config " .. cfg.shortname)
		end

		-- Make sure we're outputting dependency files as ninja doesn't work properly without them
		if not config.hasDependencyFileOutput(cfg) then
			cfg.flags.CreateDependencyFile = 'CreateDependencyFile'
		end

		for _,tool in Seq:ipairs(toolset.tools)
		:where(function(t) return not scope:get(toolsetName .. '_' .. t.toolName);end)
		:where(function(t) return t.binaryName ~= '' end)
		:each()
		do
			local toolName = toolsetName .. '_' .. tool.toolName
			local toolDef = {}
			local depfileSuffix = (tool.suffixes['depfileOutput'] or '.d')
			scope:set(toolName, toolDef)

			if buildpaths and buildpaths ~= 'root' then
				depfileSuffix = depfileSuffix..buildpaths
			end

			local toolInputs = tool:decorateInputs(cfg, '$out', '$in')
			local depfileName = nil
			if tool:hasDependencyFileOutput(cfg) then
				depfileName = '$out' .. depfileSuffix
			end

			-- Set up tool vars
			_pt('# Tool ' .. toolName)

			local toolVars = {}

			-- Extract command line args as build variables

			for k,v in pairs(toolInputs) do

				if not ninja.notBuildVar[k] then
					-- Register build variable
					local varName = toolName .. '_'..k
					toolDef[k] = v
					toolVars[k] = ninja.escVarName(varName)

					-- Write build variable default value
					if v ~= '' then
						-- Substitute repoRoot as $root
						v = ninja.toRelPath(v)

						local varName,found = scope:set(varName, v)
						if not found then
							_pt(varName .. '=' .. tostring(v))
						end
					else
						-- keep a record that it's blank
						scope:set(varName, v)
					end
				else
					toolVars[k] = v
				end
			end

			-- get the ordering correct
			for _,v in ipairs(tool.decorateArgs) do
				local varName = toolVars[v] or ninja.escVarName(toolName .. '_'..v)
				table.insert( toolVars, varName )
			end

			local description
			if tool.getDescription then
				description = ninja.escVarName(toolName..'_description')
			else
				description = tool.toolName.. ' $out'
			end

			_pt('rule ' .. toolName)
			local cmdLine = tool:getCommandLine(toolVars)
			_pt('  command=' .. cmdLine )
			if depfileName then
				_pt('  depfile=' .. depfileName )
			end
			_pt('  description=' ..description)
			_pt('')
		end
	end

	timer.stop(tmr)
end

--
-- Write out a file which sets build variables & includes, then subninjas to the actual build
--
function ninja.generateDefaultBuild(dir, scope, sln, buildFilename)
	if not buildFilename then
		buildFilename = path.join(dir, 'build.ninja')
	end
	local f = premake.generateStart(buildFilename, true)

	if sln then
		_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	else
		_p('# build.ninja autogenerated by Premake')
	end
	_p('# Ninja build is available to download at http://martine.github.com/ninja/')
	_p('# Type "ninja help" for usage help')
	_p('')

	ninja.writeRoot(dir)

	_p('# Main Build')
	_p('subninja $builddir/buildedges.ninja')
	_p('')

	if sln and scope.slntargets then
		local targets = scope.slntargets[sln.name]
		for _,includeSlnName in ipairs(sln.includesolution or {}) do
			mergeTargets(targets, scope.slntargets[includeSlnName])
		end

		ninja.writeDefaultTargets(targets)
	else
		ninja.writeDefaultTargets(scope.alltargets)
	end

	--[[
	local scope = ninja.newScope(buildFilename)

	_p('# Solution includes')
	if sln.includesolution then
	for _,slnName in ipairs(sln.includesolution) do
	local extSln = targets.solution[slnName]
	if extSln then
	_p('subninja '..scope:getBest(ninja.getSolutionBuildFilename(extSln)))
	end
	end
	end
	_p('')

	_p('include ' .. scope:getBest(ninja.getSolutionBuildFilename(sln)))
	]]

	premake.generateEnd(f, buildFilename)
end